TODO

- RAII
    - implement resource release (partially done)
- libkoala interface
    - CmId::connect()
    - CmIdListener::bind()
    - CmIdListener::incoming()
    - CmIdListener::accept()
- shmem-ipc
    - Error::Disconnected
    -[x] remove the blocking send/recv
    -[x] expose current available count to read/write
- Thread-safety
    - Add spinlock to QueuePair, CompletionQueue...
- GetSendComp() is currently busy spinning
- overlapped memory registration (two non-overlapped regions sharing one
  virtual page), currently, we just avoid this in the example code.
-[x] balance poll_cq and post_send/recv, reduce redundant poll_cq
    - use seperate queues can work, but still can cause HOL among
      multiple CQs

- Finally find a solution to deal with Fd/Handle that can come from
  everywhere: use explicit open/close call to update the reference count
  of the corresponding object at the backend.
- Add AsHandle Trait so that open_or_create_resource can do sanity check
- Use FnvHashMap in transport/engine
- Change to Ordering::Relaxed
- Most of the resources in transport/engine should be per-user, lock or
  concurrent data structure is needed

- Couple memory allocation and registration
    - Owned MemoryRegion
    - Type-safe memory region and post_send/recv

- What should Engine::run() return? (Error handling)

- clean and release the resource after detected a user app is
  disconnected.
